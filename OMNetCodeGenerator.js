/*globals define*/
/*jshint node:true, browser:true*/

/**
 * Generated by PluginGenerator 2.16.0 from webgme on Sun Dec 03 2017 13:34:34 GMT-0600 (CST).
 * A plugin that inherits from the PluginBase. To see source code documentation about available
 * properties and methods visit %host%/docs/source/PluginBase.html.
 */

define([
    'plugin/PluginConfig',
    'text!./metadata.json',
    'plugin/PluginBase'
], function (
    PluginConfig,
    pluginMetadata,
    PluginBase) {
    'use strict';

    pluginMetadata = JSON.parse(pluginMetadata);

    /**
     * Initializes a new instance of OMNetCodeGenerator.
     * @class
     * @augments {PluginBase}
     * @classdesc This class represents the plugin OMNetCodeGenerator.
     * @constructor
     */
    var OMNetCodeGenerator = function () {
        // Call base class' constructor.
        PluginBase.call(this);
        this.pluginMetadata = pluginMetadata;
    };

    /**
     * Metadata associated with the plugin. Contains id, name, version, description, icon, configStructue etc.
     * This is also available at the instance at this.pluginMetadata.
     * @type {object}
     */
    OMNetCodeGenerator.metadata = pluginMetadata;

    // Prototypical inheritance from PluginBase.
    OMNetCodeGenerator.prototype = Object.create(PluginBase.prototype);
    OMNetCodeGenerator.prototype.constructor = OMNetCodeGenerator;

    /**
     * Main function for the plugin to execute. This will perform the execution.
     * Notes:
     * - Always log with the provided logger.[error,warning,info,debug].
     * - Do NOT put any user interaction logic UI, etc. inside this method.
     * - callback always has to be called even if error happened.
     *
     * @param {function(string, plugin.PluginResult)} callback - the result callback
     */
    OMNetCodeGenerator.prototype.main = function (callback) {
        // Use self to access core, project, result, logger etc from PluginBase.
        // These are all instantiated at this point.
        var self = this,
        	core = this.core,
        	logger = this.logger,
            activeNode = this.activeNode,
        	modelJson = {
        		name: '',
        		sensors: [],
        		actuators: [],
            controller: [],
            phypro: []
        	},
            activeNode,
            counta=0,
            counts=0,
            CN,
            PN;

        function atSensor(node) {
        	var sensorData = {
        		name: '',
            xpos: 0,
            ypos: 0,
            messlength: 0,
            timebtw: 0,
            srange: 0,
            attacked: null,
            intrange: 0,
            portnumin: 0,
            portnumout: 0
        	};
            sensorData.name = core.getAttribute(node,'name');
            sensorData.xpos = core.getAttribute(node,'xpos');
            sensorData.ypos = core.getAttribute(node,'ypos');
            sensorData.messlength = core.getAttribute(node,'mess_length');
            sensorData.timebtw = core.getAttribute(node,'time_between');
            sensorData.srange = core.getAttribute(node,'srange');
            sensorData.attacked = core.getAttribute(node,'attacked');
            sensorData.intrange = core.getAttribute(node,'int_range');
            sensorData.portnumin = core.getAttribute(node,'port_num_receive');
            sensorData.portnumout = core.getAttribute(node,'port_num_send');
            counts+=1;
            modelJson.sensors.push(sensorData);
        }

        function atActuator(node) {
        	var actuatorData = {
        		name: '',
            xpos: 0,
            ypos: 0,
            attacked: null,
            arange: 0,
            intrange: 0,
            messlength: 0,
            timebtw: 0,
            portnumin: 0,
            portnumout: 0
        	};

        	actuatorData.name = core.getAttribute(node,'name');
          actuatorData.xpos = core.getAttribute(node,'xpos');
          actuatorData.ypos = core.getAttribute(node,'ypos');
          actuatorData.attacked = core.getAttribute(node,'attacked');
          actuatorData.arange = core.getAttribute(node,'arange');
          actuatorData.intrange = core.getAttribute(node,'int_range');
          actuatorData.messlength = core.getAttribute(node,'mess_length');
          actuatorData.timebtw = core.getAttribute(node,'time_between');
          actuatorData.portnumin = core.getAttribute(node,'port_num_receive');
          actuatorData.portnumout = core.getAttribute(node,'port_num_send');
          counta+=1;
          modelJson.actuators.push(actuatorData);
        }

        function atController(node) {
            var controllerData = {
                name: '',
                crange: 0,
                xpos: 0,
                ypos: 0,
                simlength: 0,
                messlength: 0,
                timebtw: 0
            };

            controllerData.name = core.getAttribute(node,'name');
            controllerData.crange = core.getAttribute(node,'crange');
            controllerData.xpos = core.getAttribute(node,'xpos');
            controllerData.ypos = core.getAttribute(node,'ypos');
            controllerData.simlength = core.getAttribute(node,'sim_length');
            controllerData.messlength = core.getAttribute(node, 'mess_length');
            controllerData.timebtw = core.getAttribute(node, 'time_between');
            CN = controllerData.name;
            modelJson.controller.push(controllerData);
        }

        function atPhyPro(node) {
          var phyproData = {
            name: '',
            prange: 0,
            xpos: 0,
            ypos: 0,
            messlength: 0,
            timebtw: 0
          };

          phyproData.name = core.getAttribute(node,'name');
          phyproData.prange = core.getAttribute(node,'prange');
          phyproData.xpos = core.getAttribute(node,'xpos');
          phyproData.ypos = core.getAttribute(node,'ypos');
          phyproData.messlength = core.getAttribute(node,'mess_length');
          phyproData.timebtw = core.getAttribute(node,'time_between');
          PN = phyproData.name;
          modelJson.phypro.push(phyproData);
        }

        function getINIcontent() {
          var j=counts;
          var s=0;
          var ini = '[Config Wireless01]\n' + 'description = Plant model communicating wirelessly\n';
          modelJson.controller.forEach(function (data) {
            ini += 'network = MIC_DEMO\n' + 'sim-time-limit = '+data.simlength+'s\n\n';
          });
          ini += '*.Sensor_*.networkLayer.arpType = "GlobalARP"\n'+'*.Actuator_*.networkLayer.arpType = "GlobalARP"\n';
          ini += '*.Physical_Process_*.networkLayer.arpType = "GlobalARP"\n'+'*.Controller_*.networkLayer.arpType = "GlobalARP"\n\n';

          modelJson.sensors.forEach(function (data) {
            ini+='*.Sensor_'+data.name+'.numUdpApps = 2\n';
            ini+='*.Sensor_'+data.name+'.udpApp[0].typename = "UDPSink"\n';
            ini+='*.Sensor_'+data.name+'.udpApp[0].localPort = '+data.portnumin+'\n';
            ini+='*.Sensor_'+data.name+'.udpApp[1].typename = "UDPBasicApp"\n';
            ini+='*.Sensor_'+data.name+'.udpApp[1].destAddresses = "Controller_'+CN+'"\n';
            ini+='*.Sensor_'+data.name+'.udpApp[1].destPort = '+data.portnumout+'\n';
            ini+='*.Sensor_'+data.name+'.udpApp[1].messageLength = '+data.messlength+'B\n';
            ini+='*.Sensor_'+data.name+'.udpApp[1].sendInterval = exponential('+data.timebtw+'ms)\n';
            ini+='*.Sensor_'+data.name+'.udpApp[1].packetName = "'+data.name+'_Reading"\n\n';
          });
          modelJson.controller.forEach(function (data) {
            var count=counta+counts;
            var i=0;
            ini+='*.Controller_'+data.name+'.numUdpApps = '+String(count)+'\n';
            modelJson.sensors.forEach(function (data) {
              ini+='*.Controller_'+CN+'.udpApp['+String(i)+'].typename = "UDPSink"\n';
              ini+='*.Controller_'+CN+'.udpApp['+String(i)+'].localPort = '+data.portnumout+'\n';
              i++;
            });
            for (var j=counts;j<count;j++){
              ini+='*.Controller_'+data.name+'.udpApp['+String(j)+'].typename = "UDPBasicApp"\n';
              ini+='*.Controller_'+data.name+'.udpApp['+String(j)+'].messageLength = '+data.messlength+'B\n';
              ini+='*.Controller_'+data.name+'.udpApp['+String(j)+'].sendInterval = exponential('+data.timebtw+'ms)\n';
            }
            modelJson.actuators.forEach(function (data) {
              ini+='*.Controller_'+CN+'.udpApp['+String(i)+'].destAddresses = "Actuator_'+data.name+'"\n';
              ini+='*.Controller_'+CN+'.udpApp['+String(i)+'].destPort = '+data.portnumin+'\n';
              ini+='*.Controller_'+CN+'.udpApp['+String(i)+'].packetName = "'+data.name+'_Command"\n';
              i++;
            });
            ini+='\n';
          });
          modelJson.actuators.forEach(function (data) {
            ini+='*.Actuator_'+data.name+'.numUdpApps = 2\n';
            ini+='*.Actuator_'+data.name+'.udpApp[0].typename = "UDPSink"\n';
            ini+='*.Actuator_'+data.name+'.udpApp[0].localPort = '+data.portnumin+'\n';
            ini+='*.Actuator_'+data.name+'.udpApp[1].typename = "UDPBasicApp"\n';
            ini+='*.Actuator_'+data.name+'.udpApp[1].destAddresses = "Physical_Process_'+PN+'"\n';
            ini+='*.Actuator_'+data.name+'.udpApp[1].destPort = '+data.portnumout+'\n';
            ini+='*.Actuator_'+data.name+'.udpApp[1].messageLength = '+data.messlength+'B\n';
            ini+='*.Actuator_'+data.name+'.udpApp[1].sendInterval = exponential('+data.timebtw+'ms)\n';
            ini+='*.Actuator_'+data.name+'.udpApp[1].packetName = "'+data.name+'_Change"\n\n';
          });
          modelJson.phypro.forEach(function (data) {
            var count=counta+counts;
            var i=0;
            ini+='*.Physical_Process_'+data.name+'.numUdpApps = '+String(count)+'\n';
            modelJson.actuators.forEach(function (data) {
              ini+='*.Physical_Process_'+PN+'.udpApp['+String(i)+'].typename = "UDPSink"\n';
              ini+='*.Physical_Process_'+PN+'.udpApp['+String(i)+'].localPort = '+data.portnumout+'\n';
              i++;
            });
            for (var j=counts;j<count;j++){
              ini+='*.Physical_Process_'+data.name+'.udpApp['+String(j)+'].typename = "UDPBasicApp"\n';
              ini+='*.Physical_Process_'+data.name+'.udpApp['+String(j)+'].messageLength = '+data.messlength+'B\n';
              ini+='*.Physical_Process_'+data.name+'.udpApp['+String(j)+'].sendInterval = exponential('+data.timebtw+'ms)\n';
            }
            modelJson.sensors.forEach(function (data) {
              ini+='*.Physical_Process_'+PN+'.udpApp['+String(i)+'].destAddresses = "Sensor_'+data.name+'"\n';
              ini+='*.Physical_Process_'+PN+'.udpApp['+String(i)+'].destPort = '+data.portnumin+'\n';
              ini+='*.Physical_Process_'+PN+'.udpApp['+String(i)+'].packetName = "'+data.name+'_Result"\n';
              i++;
            });
            ini+='\n';
          });
          ini+='*.Sensor_*.wlan[0].typename = "IdealWirelessNic"\n';
          ini+='*.Sensor_*.wlan[0].mac.useAck = false\n';
          ini+='*.Sensor_*.wlan[0].mac.fullDuplex = false\n';
          modelJson.sensors.forEach(function(data){
            ini+='*.Sensor_'+data.name+'*.wlan[0].radio.transmitter.communicationRange = '+data.srange+'m\n';
            if (data.attacked){
              ini+='*.Sensor_'+data.name+'*.wlan[0].radio.receiver.ignoreInterference = false\n';
              ini+='*.Sensor_'+data.name+'*.wlan[0].radio.transmitter.interferenceRange = '+data.intrange+'m\n';
            }
            else{
              ini+='*.Sensor_'+data.name+'*.wlan[0].radio.receiver.ignoreInterference = true\n';
            }
          });

          ini+='\n*.Sensor_*.**.bitrate = 1Mbps\n\n';

          modelJson.controller.forEach(function(data){
            ini+='*.Controller_*.wlan[0].typename = "IdealWirelessNic"\n';
            ini+='*.Controller_*.wlan[0].mac.useAck = false\n';
            ini+='*.Controller_*.wlan[0].mac.fullDuplex = false\n';
            ini+='*.Controller_*.wlan[0].radio.transmitter.communicationRange = '+data.crange+'m\n';
            ini+='*.Controller_*.wlan[0].radio.receiver.ignoreInterference = true\n\n';
          });

          ini+='*.Controller_*.**.bitrate = 1Mbps\n\n';

          ini+='*.Actuator_*.wlan[0].typename = "IdealWirelessNic"\n';
          ini+='*.Actuator_*.wlan[0].mac.useAck = false\n';
          ini+='*.Actuator_*.wlan[0].mac.fullDuplex = false\n';
          modelJson.actuators.forEach(function (data) {
            ini+='*.Actuator_'+data.name+'*.wlan[0].radio.transmitter.communicationRange = '+data.arange+'m\n';
            if (data.attacked){
              ini+='*.Actuator_'+data.name+'*.wlan[0].radio.receiver.ignoreInterference = false\n';
              ini+='*.Actuator_'+data.name+'*.wlan[0].radio.transmitter.interferenceRange = '+data.intrange+'m\n';
            }
            else{
              ini+='*.Actuator_'+data.name+'*.wlan[0].radio.receiver.ignoreInterference = true\n';
            }
          });

          ini+='\n*.Actuator_*.**.bitrate = 1Mbps\n\n';

          modelJson.phypro.forEach(function(data){
            ini+='*.Physical_Process_*.wlan[0].typename = "IdealWirelessNic"\n';
            ini+='*.Physical_Process_*.wlan[0].mac.useAck = false\n';
            ini+='*.Physical_Process_*.wlan[0].mac.fullDuplex = false\n';
            ini+='*.Physical_Process_*.wlan[0].radio.transmitter.communicationRange = '+data.prange+'m\n';
            ini+='*.Physical_Process_*.wlan[0].radio.receiver.ignoreInterference = true\n\n';
          });

          ini+='*.Physical_Process_*.**.bitrate = 1Mbps';

          logger.info(ini);
          return ini;
        }

        function getNEDcontent() {
          var ned='';

          ned+='package inet.examples.MIC;\n\n';

          ned+='import inet.common.figures.DelegateSignalConfigurator;\n';
          ned+='import inet.networklayer.configurator.ipv4.IPv4NetworkConfigurator;\n';
          ned+='import inet.node.inet.INetworkNode;\n';
          ned+='import inet.physicallayer.contract.packetlevel.IRadioMedium;\n';
          ned+='import inet.visualizer.contract.IIntegratedVisualizer;\n\n';

          ned+='network MIC_DEMO\n';
          ned+='{\n';
          ned+='  parameters:\n';
          ned+='    string hostType = default("WirelessHost");\n';
          ned+='    string mediumType = default("IdealRadioMedium");\n\n';
          ned+='    @display("bgb=1000,1000;bgg=100,1,grey95");\n\n';
          ned+='  submodules:\n';
          ned+='    configurator: IPv4NetworkConfigurator {\n';
          ned+='      @display("p=200,50");\n';
          ned+='    }\n';
          ned+='    radioMedium: <mediumType> like IRadioMedium {\n';
          ned+='      @display("p=950,50");\n';
          ned+='    }\n';

          modelJson.sensors.forEach(function (data) {
            ned += '    Sensor_'+data.name+': <hostType> like INetworkNode {\n';
            ned += '      @display("p='+data.xpos+','+data.ypos+'");\n';
            ned += '    }\n';
          });
          modelJson.controller.forEach(function (data) {
            ned += '    Controller_'+data.name+': <hostType> like INetworkNode {\n';
            ned += '      @display("p='+data.xpos+','+data.ypos+'");\n';
            ned += '    }\n';
          });
          modelJson.actuators.forEach(function (data) {
            ned += '    Actuator_'+data.name+': <hostType> like INetworkNode {\n';
            ned += '      @display("p='+data.xpos+','+data.ypos+'");\n';
            ned += '    }\n';
          });
          modelJson.phypro.forEach(function (data) {
            ned += '    Physical_Process_'+data.name+': <hostType> like INetworkNode {\n';
            ned += '      @display("p='+data.xpos+','+data.ypos+'");\n';
            ned += '    }\n';
          });
          ned+='}';
          logger.info(ned);
          return ned;
        }

    	self.loadNodeMap(activeNode)
			.then(function (nodes) {
				var nodePath,
					node,
          artifact;

				/*for (nodePath in nodes){
					logger.info(core.getAttribute(nodes[nodePath], 'name'), 'has path', nodePath);
				}*/

				modelJson.name = core.getAttribute(activeNode, 'name');

				var childrenPaths = core.getChildrenPaths(activeNode);

				for (var i=0; i<childrenPaths.length; i+=1){
					node = nodes[childrenPaths[i]];
					if (self.isMetaTypeOf(node,self.META.Sensor)) {
						atSensor(node);
					}
					else if (self.isMetaTypeOf(node, self.META.Controller)) {
						atController(node);
					}
          else if (self.isMetaTypeOf(node, self.META.Actuator)) {
            atActuator(node);
          }
          else if(self.isMetaTypeOf(node, self.META.Physical_Process)) {
            atPhyPro(node);
          }
				}

        let SJson = JSON.stringify(modelJson,null,2);

				//self.logger.info(SJson);

        var omnini=getINIcontent();
        var omnned=getNEDcontent();

                artifact = self.blobClient.createArtifact('MyArtifact');
                artifact.addFiles({
                    //'OMN.json': SJson,
                    'MIC.ini': omnini,
                    'MIC.ned': omnned
                })
                .then(function (fileMetadataHashes) {
                  self.result.addArtifact(fileMetadataHashes[0]);
                  self.result.addArtifact(fileMetadataHashes[1]);
                  //self.result.addArtifact(fileMetadataHashes[2]);
                  return artifact.save();
                })
                .then(function (artifactHash) {
                  self.result.addArtifact(artifactHash);
                  self.result.setSuccess(true);
                  callback(null, self.result);
                })
                .catch(function (err) {
                  callback(err);
                });
              })
            .catch(function (err) {
                logger.error(err.stack);
                callback(err, self.result);
            });

    };

    return OMNetCodeGenerator;
});
